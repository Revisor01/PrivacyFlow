import SwiftUI

struct PagesView: View {
    let website: Website

    @StateObject private var viewModel: PagesViewModel
    @State private var selectedDateRange: DateRange = .thisWeek

    init(website: Website) {
        self.website = website
        _viewModel = StateObject(wrappedValue: PagesViewModel(websiteId: website.id))
    }

    var body: some View {
        List {
            if viewModel.isLoading {
                Section {
                    HStack {
                        Spacer()
                        ProgressView()
                        Spacer()
                    }
                    .padding()
                }
            } else {
                pagesSection
            }
        }
        .navigationTitle(String(localized: "pages.title"))
        .navigationBarTitleDisplayMode(.inline)
        .toolbar {
            ToolbarItem(placement: .topBarTrailing) {
                Menu {
                    ForEach(DateRange.allCases, id: \.preset) { range in
                        Button {
                            selectedDateRange = range
                        } label: {
                            if selectedDateRange.preset == range.preset {
                                Label(range.displayName, systemImage: "checkmark")
                            } else {
                                Text(range.displayName)
                            }
                        }
                    }
                } label: {
                    Text(selectedDateRange.displayName)
                        .font(.subheadline)
                }
            }
        }
        .task {
            await viewModel.loadData(dateRange: selectedDateRange)
        }
        .onChange(of: selectedDateRange) { _, newValue in
            Task {
                await viewModel.loadData(dateRange: newValue)
            }
        }
    }

    private var pagesSection: some View {
        Section {
            if viewModel.combinedPages.isEmpty {
                ContentUnavailableView(
                    String(localized: "pages.empty"),
                    systemImage: "doc.text",
                    description: Text(String(localized: "pages.empty.description"))
                )
            } else {
                ForEach(viewModel.combinedPages) { page in
                    PageRow(page: page, baseURL: website.domain ?? website.name)
                }
            }
        } header: {
            HStack {
                Text(String(localized: "pages.visited"))
                Spacer()
                Text("\(viewModel.combinedPages.count) " + String(localized: "pages.count"))
                    .font(.caption)
                    .foregroundStyle(.secondary)
            }
        } footer: {
            Text(String(localized: "pages.showFullUrl"))
        }
    }
}

struct PageRow: View {
    let page: CombinedPage
    let baseURL: String

    var body: some View {
        HStack(alignment: .top) {
            VStack(alignment: .leading, spacing: 4) {
                // Titel oben
                Text(page.title.isEmpty ? String(localized: "website.noTitle") : page.title)
                    .font(.subheadline)
                    .fontWeight(.medium)
                    .lineLimit(2)

                // Vollständige URL darunter
                Text(fullURL)
                    .font(.caption)
                    .foregroundStyle(.secondary)
                    .lineLimit(2)
            }

            Spacer()

            Text(page.views.formatted())
                .font(.subheadline)
                .fontWeight(.semibold)
                .foregroundStyle(.primary)
        }
        .padding(.vertical, 6)
    }

    private var fullURL: String {
        let cleanDomain = baseURL.replacingOccurrences(of: "https://", with: "")
            .replacingOccurrences(of: "http://", with: "")
            .replacingOccurrences(of: "www.", with: "")
        return cleanDomain + page.path
    }
}

// Kombinierte Seite mit Titel und Pfad
struct CombinedPage: Identifiable {
    let id: String
    let title: String
    let path: String
    let views: Int

    init(title: String, path: String, views: Int) {
        self.id = "\(title)-\(path)"
        self.title = title
        self.path = path
        self.views = views
    }
}

@MainActor
class PagesViewModel: ObservableObject {
    let websiteId: String

    @Published var topPages: [MetricItem] = []
    @Published var pageTitles: [MetricItem] = []
    @Published var combinedPages: [CombinedPage] = []
    @Published var isLoading = false

    private let api = UmamiAPI.shared

    init(websiteId: String) {
        self.websiteId = websiteId
    }

    func loadData(dateRange: DateRange) async {
        isLoading = true
        defer { isLoading = false }

        async let pagesTask = api.getMetrics(websiteId: websiteId, dateRange: dateRange, type: .path, limit: 100)
        async let titlesTask = api.getMetrics(websiteId: websiteId, dateRange: dateRange, type: .title, limit: 100)

        do {
            topPages = try await pagesTask
        } catch {
            #if DEBUG
            print("Failed to load top pages: \(error)")
            #endif
        }

        do {
            pageTitles = try await titlesTask
        } catch {
            #if DEBUG
            print("Failed to load page titles: \(error)")
            #endif
        }

        // Kombiniere Titel und Pfade
        combinedPages = createCombinedPages()
    }

    private func createCombinedPages() -> [CombinedPage] {
        // Erstelle eine Liste mit allen Pfaden und versuche passende Titel zu finden
        var result: [CombinedPage] = []
        var usedTitles: Set<String> = []

        for page in topPages {
            let matchingTitle = findBestTitleMatch(for: page, excluding: usedTitles)

            if let title = matchingTitle {
                usedTitles.insert(title.name)
                result.append(CombinedPage(
                    title: title.name,
                    path: page.name,
                    views: page.value
                ))
            } else {
                // Kein passender Titel gefunden - verwende Pfad als Fallback
                result.append(CombinedPage(
                    title: extractTitleFromPath(page.name),
                    path: page.name,
                    views: page.value
                ))
            }
        }

        return result.sorted { $0.views > $1.views }
    }

    private func findBestTitleMatch(for page: MetricItem, excluding usedTitles: Set<String>) -> MetricItem? {
        // Strategie 1: Exakte Übereinstimmung der Aufrufzahlen
        if let exactMatch = pageTitles.first(where: {
            $0.value == page.value && !usedTitles.contains($0.name)
        }) {
            return exactMatch
        }

        // Strategie 2: Ähnliche Aufrufzahlen (±5%)
        let tolerance = max(1, Int(Double(page.value) * 0.05))
        if let closeMatch = pageTitles.first(where: {
            abs($0.value - page.value) <= tolerance && !usedTitles.contains($0.name)
        }) {
            return closeMatch
        }

        // Strategie 3: Noch breitere Toleranz (±15%)
        let broaderTolerance = max(2, Int(Double(page.value) * 0.15))
        return pageTitles.first(where: {
            abs($0.value - page.value) <= broaderTolerance && !usedTitles.contains($0.name)
        })
    }

    // Versuche einen sinnvollen Titel aus dem Pfad zu extrahieren
    private func extractTitleFromPath(_ path: String) -> String {
        // Für /details?postId=123 -> "Details"
        // Für /kontakt -> "Kontakt"
        // Für / -> "Startseite"

        if path == "/" {
            return String(localized: "pages.homepage")
        }

        // Extrahiere den Hauptpfad ohne Query-Parameter
        let mainPath = path.split(separator: "?").first ?? Substring(path)

        // Entferne führenden Slash und nimm den letzten Teil
        let segments = mainPath.trimmingCharacters(in: CharacterSet(charactersIn: "/"))
            .split(separator: "/")

        if let lastSegment = segments.last {
            // Formatiere: details -> Details, mein-artikel -> Mein Artikel
            return String(lastSegment)
                .replacingOccurrences(of: "-", with: " ")
                .replacingOccurrences(of: "_", with: " ")
                .capitalized
        }

        return path
    }
}

#Preview {
    NavigationStack {
        PagesView(
            website: Website(
                id: "1",
                name: "Test Website",
                domain: "kirche-wesselburen.de",
                shareId: nil,
            teamId: nil,
                resetAt: nil,
                createdAt: nil
            )
        )
    }
}
